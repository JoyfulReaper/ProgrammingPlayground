// Apply Function
// Common names: apply, ap
// commom operators: <*>
// Unpacks a function wrapped inside an elevated value into a lifted function E<a> -> E<b>
// Signature: E<(a -> b)> -> E<a> -> E<b>

// Unpacks a function wrapped inside an elevated value (E<a -> b>) into a lifted function E<a> -> E<b>
// Allows lifting of multi-parameter function in the normal world into a multi-parameter function in the elevated world

// Alternative interpretation: Two parameter function that takes an elevated value (E<a>) and elevated function (E<a -> b>) and returns a new
// elevated value (E<b>) generated by applying the function a -> b to the internal elements of E<a>

module Option =
    // The apply function for Options
    let apply fOpt xOpt =
        match fOpt, xOpt with
        | Some f, Some x -> Some (f x)
        | _ -> None

module List =
    // The apply function for Lists
    // [f;g] apply [x;y] becomes [f x; f y; g x; g y]
    let apply (fList: ('a -> 'b) list) (xList: 'a list) =
        [ for f in fList do
          for x in xList do
            yield f x]

// Infix Version
// Since using Apply can be akward it is common to create an infex version, typically <*>

let add x y =
    x + y

let resultOption =
    let (<*>) = Option.apply
    (Some add) <*> (Some 2) <*> (Some 3)

let resultList =
   let (<*>) = List.apply
   [add] <*> [1;2] <*> [10;20]

// Apply VS Map
// map can be constructed from apply and return, but not vice versa
// Return then Apply is the same result as Map

// Simplifed Infex Notation:
let resultOption2 =
    let (<!>) = Option.map
    let (<*>) = Option.apply

    add <!> (Some 2) <*> (Some 3)

let resultList2 =
    let (<!>) = List.map
    let (<*>) = List.apply

    add <!> [1;2] <*> [10;20]

let batman =
    let (<!>) = List.map
    let (<*>) = List.apply

    // string concatenation using +
    (+) <!> ["bam"; "kapow"; "zap"] <*> ["!"; "!!"]